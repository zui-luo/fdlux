<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>完美Python参数编辑器体验方案</title>
    <style>
        :root {
            --primary: #1890ff;
            --bg: #1e1e1e;
            --text: #d4d4d4;
            --border: #333;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 90vh;
        }
        .header {
            padding: 20px;
            border-bottom: 1px solid #eee;
        }
        .header h1 { margin: 0 0 10px 0; font-size: 20px; }
        .tabs {
            display: flex;
            background: #fafafa;
            border-bottom: 1px solid #e8e8e8;
        }
        .tab-btn {
            padding: 12px 24px;
            cursor: pointer;
            border: none;
            background: transparent;
            font-weight: 500;
            opacity: 0.7;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
        }
        .tab-btn:hover { color: var(--primary); opacity: 1; }
        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            opacity: 1;
            background: #fff;
        }
        .desc-panel {
            padding: 15px 20px;
            background: #e6f7ff;
            border-left: 4px solid var(--primary);
            font-size: 14px;
            color: #555;
            line-height: 1.6;
        }
        #editor-container {
            flex: 1;
            min-height: 500px;
            position: relative;
        }
        
        /* 方案二的自定义装饰器样式 */
        .my-param-decoration {
            background-color: rgba(24, 144, 255, 0.2);
            border-radius: 4px;
            border: 1px solid rgba(24, 144, 255, 0.4);
            color: #fff !important;
            font-weight: bold;
        }
        /* 强制覆盖monaco内部文字颜色以配合胶囊背景 */
        .my-param-decoration-text {
            color: #4fc1ff !important; 
        }

    </style>
    <!-- 引入 Monaco Editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.38.0/min/vs/loader.min.js" 
            onload="window.monacoLoaderReady = true;"
            onerror="window.monacoLoaderError = true; document.getElementById('desc-text').innerHTML = '<span style=\'color: red;\'>Monaco Editor 脚本加载失败，请检查网络连接。</span>';"></script>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>B端体验设计：Python编辑器 - 动态参数 ${VAR} 解决方案</h1>
    </div>
    
    <div class="tabs">
        <button class="tab-btn active" onclick="switchMode(1)">方案一：自定义语法高亮 (沉浸式)</button>
        <button class="tab-btn" onclick="switchMode(2)">方案二：视觉胶囊化 (低代码风格)</button>
        <button class="tab-btn" onclick="switchMode(3)">方案三：快捷键触发 (高效率)</button>
    </div>

    <div class="desc-panel" id="desc-text">
        正在加载编辑器...
    </div>

    <div id="editor-container"></div>
</div>

<script>
    let editor;
    let currentMode = 1;
    let decorations = []; // 用于方案二的装饰器集合

    // 模拟的后台参数列表
    const PARAM_SUGGESTIONS = [
        { label: 'user_id', detail: '当前用户ID', type: 'Integer' },
        { label: 'current_date', detail: 'YYYY-MM-DD', type: 'String' },
        { label: 'db_connection', detail: '数据库连接串', type: 'Object' },
        { label: 'api_token', detail: '鉴权Token', type: 'String' }
    ];

    // 等待loader加载完成后再初始化
    function initMonaco() {
        // 检查是否有加载错误
        if (window.monacoLoaderError) {
            return; // 错误已在onerror中处理
        }

        // 检查loader是否已加载
        if (typeof require === 'undefined') {
            // 如果loader还没加载，等待一下再试
            if (!window.monacoLoaderReady) {
                setTimeout(initMonaco, 200);
                return;
            }
            document.getElementById('desc-text').innerHTML = 
                '<span style="color: red;">错误：Monaco Editor 加载失败，请检查网络连接或刷新页面重试。</span>';
            return;
        }

        // 配置Monaco Editor路径
        require.config({
            paths: { 
                'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.38.0/min/vs' 
            }
        });

        // 加载Monaco Editor主模块
        require(['vs/editor/editor.main'], function() {
            try {
                initEditor();
            } catch (error) {
                console.error('编辑器初始化错误:', error);
                document.getElementById('desc-text').innerHTML = 
                    '<span style="color: red;">编辑器初始化失败：' + error.message + '</span>';
            }
        }, function(err) {
            console.error('Monaco Editor 加载失败:', err);
            document.getElementById('desc-text').innerHTML = 
                '<span style="color: red;">Monaco Editor 加载失败，请检查网络连接。错误信息：' + (err.message || '未知错误') + '</span>';
        });
    }

    // 页面加载完成后初始化
    function startInit() {
        // 如果loader已经准备好，立即初始化
        if (window.monacoLoaderReady && typeof require !== 'undefined') {
            initMonaco();
        } else {
            // 否则等待loader加载
            const checkInterval = setInterval(function() {
                if (window.monacoLoaderError) {
                    clearInterval(checkInterval);
                    return;
                }
                if (window.monacoLoaderReady && typeof require !== 'undefined') {
                    clearInterval(checkInterval);
                    initMonaco();
                }
            }, 100);
            
            // 10秒超时
            setTimeout(function() {
                clearInterval(checkInterval);
                if (typeof require === 'undefined') {
                    document.getElementById('desc-text').innerHTML = 
                        '<span style="color: red;">Monaco Editor 加载超时，请检查网络连接或刷新页面重试。</span>';
                }
            }, 10000);
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startInit);
    } else {
        startInit();
    }

    function initEditor() {
        // 1. 注册一个扩展的 python 语言，用于方案一
        monaco.languages.register({ id: 'python-extended' });
        
        // 2. 自定义 Tokenizer (词法分析器)，专门识别 ${...}
        // 这样可以把它和 Python 原生的 {} 区分开
        monaco.languages.setMonarchTokensProvider('python-extended', {
            tokenizer: {
                root: [
                    // 匹配 ${var} 结构，给予特殊的 token 名称 'custom-param'
                    [/\$\{[\w]+\}/, 'custom-param'], 
                    // 匹配标准的 python {}，给予标准 delimiter 名称 (防止冲突)
                    [/\{|\}/, 'delimiter.curly'],
                    // 其他标准 python 语法简单模拟（为了演示效果，这里简化了）
                    [/[a-z_$][\w$]*/, { cases: { '@keywords': 'keyword', '@default': 'identifier' } }],
                    [/"/,  { token: 'string.quote', bracket: '@open', next: '@string' }]
                ],
                string: [
                    [/[^"]+/, 'string'],
                    [/"/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                ],
                // 简单的关键字列表
                keywords: ['if', 'else', 'for', 'while', 'def', 'return', 'print', 'import']
            }
        });

        // 3. 定义高亮主题
        monaco.editor.defineTheme('my-custom-theme', {
            base: 'vs-dark',
            inherit: true,
            rules: [
                // 给我们的自定义 token 赋予醒目的颜色
                { token: 'custom-param', foreground: 'FFD700', fontStyle: 'bold' } 
            ],
            colors: {}
        });

        // 4. 注册自动补全提供者 (核心逻辑)
        monaco.languages.registerCompletionItemProvider('python-extended', {
            triggerCharacters: ['{', '@'], // 监听这些字符
            provideCompletionItems: function(model, position) {
                const textUntilPosition = model.getValueInRange({
                    startLineNumber: position.lineNumber,
                    startColumn: 1,
                    endLineNumber: position.lineNumber,
                    endColumn: position.column
                });

                // ========== 方案一逻辑：检测 ${ ==========
                if (currentMode === 1 || currentMode === 2) {
                    // 只有当用户输入了 ${ 时，才触发参数联想
                    // 这样避免用户输入 dict = { 'x': 1 } 时产生误扰
                    const match = textUntilPosition.match(/\$\{$/);
                    if (!match) return { suggestions: [] };

                    return {
                        suggestions: PARAM_SUGGESTIONS.map(param => ({
                            label: param.label,
                            kind: monaco.languages.CompletionItemKind.Variable,
                            detail: param.detail,
                            insertText: param.label + '}', // 自动补全右括号
                            filterText: param.label // 允许这里继续输入过滤
                        }))
                    };
                }

                // ========== 方案三逻辑：检测 @ ==========
                if (currentMode === 3) {
                    const match = textUntilPosition.match(/@$/);
                    if (!match) return { suggestions: [] };

                    return {
                        suggestions: PARAM_SUGGESTIONS.map(param => ({
                            label: param.label,
                            kind: monaco.languages.CompletionItemKind.Property,
                            detail: param.detail,
                            // 关键：用户选了这个，自动替换成 ${xxx}，删掉前面的 @
                            insertText: '${' + param.label + '}', 
                            range: {
                                startLineNumber: position.lineNumber,
                                endLineNumber: position.lineNumber,
                                startColumn: position.column - 1, // 覆盖掉 @
                                endColumn: position.column
                            }
                        }))
                    };
                }
                
                return { suggestions: [] };
            }
        });

        // 创建编辑器实例
        editor = monaco.editor.create(document.getElementById('editor-container'), {
            value: getDefaultCode(),
            language: 'python-extended',
            theme: 'my-custom-theme',
            fontSize: 14,
            minimap: { enabled: false },
            automaticLayout: true,
            scrollBeyondLastLine: false
        });

        // 监听内容变化 (用于方案二)
        editor.onDidChangeModelContent(() => {
            if (currentMode === 2) {
                updateDecorations();
            }
        });

        updateUI(1);
    }

    // 更新装饰器 (方案二核心)
    function updateDecorations() {
        const model = editor.getModel();
        const text = model.getValue();
        const regex = /\$\{([\w]+)\}/g;
        let match;
        const newDecorations = [];

        while ((match = regex.exec(text)) !== null) {
            const startPos = model.getPositionAt(match.index);
            const endPos = model.getPositionAt(match.index + match[0].length);
            
            newDecorations.push({
                range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column),
                options: {
                    inlineClassName: 'my-param-decoration my-param-decoration-text', // CSS 类名
                }
            });
        }
        
        // 应用装饰器
        decorations = editor.deltaDecorations(decorations, newDecorations);
    }

    // 切换模式逻辑
    function switchMode(mode) {
        currentMode = mode;
        
        // 更新 Tab 样式
        document.querySelectorAll('.tab-btn').forEach((btn, idx) => {
            btn.classList.toggle('active', idx + 1 === mode);
        });

        updateUI(mode);
        editor.focus();
    }

    function updateUI(mode) {
        const descEl = document.getElementById('desc-text');
        
        // 清理方案二的装饰器
        if (mode !== 2) {
             decorations = editor.deltaDecorations(decorations, []);
        } else {
             updateDecorations();
        }

        if (mode === 1) {
            descEl.innerHTML = `
                <strong>交互逻辑：</strong> 像写普通代码一样，输入 <code>\$\{</code> (注意是美元符+左花括号) 时触发联想。
                <br><strong>优势：</strong> 完美隔离了 Python 字典的 <code>{</code>。只有明确意图输入变量时才会提示。
                <br><strong>试一试：</strong> 在编辑器中输入 <code>user_data = {"name": "test"}</code> (不会触发)，然后换行输入 <code>print(\$\{</code> (会触发)。
            `;
        } else if (mode === 2) {
            descEl.innerHTML = `
                <strong>交互逻辑：</strong> 输入逻辑同上。但在识别成功后，系统会给 <code>\$\{xxx\}</code> 加上“胶囊背景”。
                <br><strong>优势：</strong> 视觉上极易区分“代码”和“外部参数”，减少非技术人员的恐惧感，防止误删参数内部字符。
                <br><strong>试一试：</strong> 观察代码中现有的 <code>\$\{user_id\}</code> 是否带有背景色。
            `;
        } else if (mode === 3) {
            descEl.innerHTML = `
                <strong>交互逻辑：</strong> 不需要输入繁琐的 <code>\$\{</code>。直接输入 <code>@</code> 唤起菜单，选中后自动转义。
                <br><strong>优势：</strong> 减少了 3 次按键 (Shift+4, Shift+[)，利用惯性思维 (由 Notion, Slack 培养的 @ 提及习惯)。
                <br><strong>试一试：</strong> 在编辑器中输入 <code>print(@</code>，选择参数，观察自动变化。
            `;
        }
    }

    function getDefaultCode() {
        return `# 示例 Python 代码
import json

# 这里的 {} 是普通的 Python 字典，不会被识别
my_dict = {
    "key": "value",
    "status": 1
}

# 下面演示参数注入

# 1. 在字符串中使用 (常见场景)
sql = "SELECT * FROM users WHERE id = ${user_id}"

# 2. 作为变量直接使用
token = ${api_token}

print(f"Connecting to database with {token}...")
`;
    }
</script>

</body>
</html>