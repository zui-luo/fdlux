<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç«¥è¶£åœ£è¯æ ‘ç”Ÿæˆå™¨</title>
    <!-- å¼•å…¥ Rough.js åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rough.js/3.1.0/rough.js"></script>
    <style>
        /* 1. å…¨å±€æ ·å¼ï¼šè®¾ç½®çº¸å¼ èƒŒæ™¯å’Œæ‰‹å†™å­—ä½“ */
        :root {
            --paper-color: #f7f5e6;
            --btn-color: #e76f51;
            --text-color: #264653;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--paper-color);
            /* å­—ä½“å›é€€æœºåˆ¶ï¼Œç¡®ä¿æ‰‹å†™æ„Ÿ */
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', sans-serif;
        }

        /* 2. èƒŒæ™¯å™ªç‚¹çº¹ç†ï¼šæ¨¡æ‹Ÿç”»çº¸ç²—ç³™æ„Ÿ */
        .paper-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.4;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            z-index: 1;
        }

        /* 3. ä¸»å®¹å™¨ */
        #app {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        /* ç”»å¸ƒæ ·å¼ */
        canvas {
            max-width: 100%;
            max-height: 80vh;
        }

        /* 4. æ‰‹ç»˜é£æ ¼æŒ‰é’® */
        .control-panel {
            position: absolute;
            bottom: 40px;
            text-align: center;
        }

        .draw-btn {
            background: transparent;
            font-family: inherit;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-color);
            padding: 12px 36px;
            cursor: pointer;
            border: none;
            outline: none;
            position: relative;
            transition: transform 0.1s ease;
        }

        /* ä½¿ç”¨ SVG èƒŒæ™¯æˆ– border-image ä¹Ÿå¯ä»¥ï¼Œè¿™é‡Œä¸ºäº†çº¯ä»£ç å®ç°ï¼Œä½¿ç”¨ CSS æ¨¡æ‹Ÿæ‰‹ç»˜è¾¹æ¡† */
        .draw-btn::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border: 3px solid var(--text-color);
            /* è¿™ä¸ª border-radius æŠ€å·§èƒ½äº§ç”Ÿä¸è§„åˆ™çš„æ¤­åœ†æ•ˆæœ */
            border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px;
            transform: rotate(-2deg);
            background-color: #fff;
            z-index: -1;
            transition: all 0.2s ease;
            box-shadow: 2px 4px 0px rgba(0,0,0,0.1);
        }
        
        .draw-btn:hover {
            transform: scale(1.05) rotate(1deg);
        }

        .draw-btn:hover::before {
            background-color: #ffe8d6;
            transform: rotate(1deg);
        }

        .draw-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>

    <div class="paper-texture"></div>

    <div id="app">
        <!-- ç”»å¸ƒåŒºåŸŸ -->
        <canvas id="canvas"></canvas>
        
        <!-- åº•éƒ¨æŒ‰é’® -->
        <div class="control-panel">
            <button class="draw-btn" id="generateBtn">æˆ‘çš„åœ£è¯æ ‘ ğŸ„</button>
        </div>
    </div>

    <script>
        // --- 1. é…ç½®ä¸åˆå§‹åŒ– ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        // åˆå§‹åŒ– Rough.js
        let rc = rough.canvas(canvas);

        // é¢œè‰²æ¿ï¼šé«˜é¥±å’Œåº¦ã€å¤å¤æ„Ÿã€èœ¡ç¬”é£
        const pallete = {
            greens: ['#2d6a4f', '#40916c', '#52b788', '#008000', '#556b2f'],
            trunks: ['#582f0e', '#7f5539', '#9c6644'],
            decorations: ['#e76f51', '#f4a261', '#e9c46a', '#2a9d8f', '#e63946', '#ffd700'],
            snow: ['#a8dadc', '#f1faee', '#cccccc']
        };

        // éšæœºå·¥å…·å‡½æ•°
        const random = (min, max) => Math.random() * (max - min) + min;
        const randomInt = (min, max) => Math.floor(random(min, max));
        const randomPick = (arr) => arr[Math.floor(Math.random() * arr.length)];

        // --- 2. æ ¸å¿ƒç»˜ç”»é€»è¾‘ ---

        // è®¾ç½®ç”»å¸ƒå°ºå¯¸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            generateTree();
        }

        // ç»˜åˆ¶ä¸è§„åˆ™å¤šè¾¹å½¢ï¼ˆæ¨¡æ‹Ÿæ‰‹ç»˜çš„æ ‘å±‚ï¼‰
        function drawRoughPolygon(points, color, fillStyle = 'hachure') {
            rc.polygon(points, {
                fill: color,
                fillStyle: fillStyle, // hachure, zigzag, cross-hatch, dots
                fillWeight: random(1, 2.5), // å¡«å……çº¿æ¡çš„ç²—ç»†
                hachureGap: random(3, 6), // å¡«å……çº¿æ¡çš„é—´è·ï¼Œå¤§ä¸€ç‚¹åƒæ¶‚è¦æŠŠä¸æ»¡
                roughness: 2.5, // ç²—ç³™åº¦ï¼šå€¼è¶Šå¤§è¶Šå‡Œä¹±
                bowing: 1.5, // å¼¯æ›²åº¦ï¼šçº¿æ¡æ˜¯å¼¯çš„è€Œä¸æ˜¯ç›´çš„
                stroke: '#1a1a1a', // è½®å»“é¢œè‰²ï¼ˆæ·±é“…ç¬”è‰²ï¼‰
                strokeWidth: 1.5
            });
        }

        // ç»˜åˆ¶è£…é¥°ç‰© (åœ†çƒ)
        function drawBauble(x, y) {
            const size = random(10, 20);
            const color = randomPick(pallete.decorations);
            const style = randomPick(['solid', 'hachure', 'zigzag']);
            
            rc.circle(x, y, size, {
                fill: color,
                fillStyle: style,
                roughness: 2,
                fillWeight: 1.5,
                hachureGap: 3,
                stroke: '#1a1a1a',
                strokeWidth: 1
            });
        }

        // ç»˜åˆ¶é¡¶éƒ¨æ˜Ÿæ˜Ÿ (ç®€æ˜“çš„ä¸è§„åˆ™å›¾æ¡ˆ)
        function drawStar(cx, cy, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            let step = Math.PI / 5;
            let points = [];

            // ç”Ÿæˆäº”è§’æ˜Ÿçš„åæ ‡ç‚¹ï¼Œå¹¶åŠ å…¥éšæœºåç§»
            for (let i = 0; i < 5; i++) {
                x = cx + Math.cos(rot) * outerRadius + random(-5, 5);
                y = cy + Math.sin(rot) * outerRadius + random(-5, 5);
                points.push([x, y]);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius + random(-5, 5);
                y = cy + Math.sin(rot) * innerRadius + random(-5, 5);
                points.push([x, y]);
                rot += step;
            }
            
            rc.polygon(points, {
                fill: '#ffd700',
                fillStyle: 'zigzag',
                fillWeight: 2,
                hachureGap: 3,
                roughness: 2,
                stroke: '#e63946', // æ˜Ÿæ˜Ÿæè¾¹ç»™ä¸ªçº¢è‰²ï¼Œæ˜¾çœ¼
                strokeWidth: 2
            });
        }

        // ç»˜åˆ¶èƒŒæ™¯å…ƒç´ ï¼ˆé›ªèŠ±/åœ†ç‚¹ï¼‰
        function drawBackground() {
            const count = 30;
            for(let i=0; i<count; i++) {
                const x = random(0, canvas.width);
                const y = random(0, canvas.height);
                const size = random(5, 15);
                const type = randomInt(0, 3); // 0: circle, 1: line, 2: cross

                const opts = { stroke: '#bdc3c7', strokeWidth: 1, roughness: 3 };
                
                if (type === 0) {
                    rc.circle(x, y, size, { ...opts, fill: randomPick(pallete.snow), fillStyle: 'dots' });
                } else if (type === 1) {
                    // ç®€å•çš„çº¿æ¡é›ªèŠ±
                    rc.line(x - size, y - size, x + size, y + size, opts);
                    rc.line(x + size, y - size, x - size, y + size, opts);
                } else {
                    // å°åœ†ç‚¹
                    rc.circle(x, y, size/2, { fill: '#ddd', fillStyle: 'solid', roughness: 0, stroke: 'none' });
                }
            }
        }

        // --- 3. ç”Ÿæˆé€»è¾‘ä¸»å‡½æ•° ---
        function generateTree() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 1. ç»˜åˆ¶èƒŒæ™¯è£…é¥°
            drawBackground();

            const centerX = canvas.width / 2;
            // æ ‘çš„åŸºç¡€å‚æ•°
            const treeBaseY = canvas.height - 150; // æ ‘åº•éƒ¨çš„Yä½ç½®
            const layers = randomInt(3, 5); // æ ‘çš„å±‚æ•° 3-4å±‚
            const layerHeight = 80; // æ¯ä¸€å±‚çš„é«˜åº¦
            
            // 2. ç»˜åˆ¶æ ‘å¹²
            const trunkWidth = 50;
            const trunkHeight = 60;
            const trunkPoints = [
                [centerX - trunkWidth/2 + random(-5, 5), treeBaseY],
                [centerX + trunkWidth/2 + random(-5, 5), treeBaseY],
                [centerX + trunkWidth/2 + random(-2, 2), treeBaseY + trunkHeight],
                [centerX - trunkWidth/2 + random(-2, 2), treeBaseY + trunkHeight]
            ];
            drawRoughPolygon(trunkPoints, randomPick(pallete.trunks), 'hachure');

            // 3. ç»˜åˆ¶æ ‘å†  (å±‚å )
            let currentY = treeBaseY;
            let currentWidth = 220; // æœ€åº•å±‚å®½åº¦

            // æˆ‘ä»¬éœ€è¦å­˜å‚¨æ¯ä¸€å±‚çš„é¡¶éƒ¨ä¸­å¿ƒç‚¹ï¼Œä»¥ä¾¿æ”¾ç½®è£…é¥°å’Œæ˜Ÿæ˜Ÿ
            let lastTopY = currentY;

            for(let i = 0; i < layers; i++) {
                const topWidth = currentWidth * 0.5; // æ¢¯å½¢é¡¶éƒ¨å®½åº¦
                const h = layerHeight + random(-10, 10);
                
                // è®¡ç®—æ¢¯å½¢å››ä¸ªç‚¹ï¼ŒåŠ å…¥éšæœºæŠ–åŠ¨è®©å½¢çŠ¶ä¸è§„åˆ™
                const p1 = [centerX - currentWidth/2 + random(-10, 10), currentY + random(-5, 5)]; // å·¦ä¸‹
                const p2 = [centerX + currentWidth/2 + random(-10, 10), currentY + random(-5, 5)]; // å³ä¸‹
                // é¡¶éƒ¨ç¨å¾®é‡å åˆ°ä¸Šä¸€å±‚çš„ä¸Šæ–¹
                const nextY = currentY - h;
                const p3 = [centerX + topWidth/2 + random(-10, 10), nextY]; // å³ä¸Š
                const p4 = [centerX - topWidth/2 + random(-10, 10), nextY]; // å·¦ä¸Š

                // é¢œè‰²å’Œå¡«å……é£æ ¼éšæœº
                const color = randomPick(pallete.greens);
                const style = randomPick(['hachure', 'zigzag', 'cross-hatch']);

                drawRoughPolygon([p1, p2, p3, p4], color, style);

                // åœ¨å½“å‰å±‚ç”»è£…é¥°çƒ
                const decorCount = randomInt(2, 5);
                for(let d=0; d<decorCount; d++) {
                    // ç®€å•çš„æ’å€¼ç®—æ³•ï¼Œè®©çƒåœ¨æ¢¯å½¢å†…éƒ¨
                    const decorY = random(nextY + 20, currentY - 10);
                    // æ ¹æ®Yè®¡ç®—å½“å‰å®½åº¦çš„èŒƒå›´ï¼Œé¿å…çƒç”»åˆ°æ ‘å¤–é¢
                    const progress = (decorY - nextY) / h;
                    const maxX = (topWidth + (currentWidth - topWidth) * progress) / 2 - 10;
                    const decorX = centerX + random(-maxX, maxX);
                    
                    drawBauble(decorX, decorY);
                }

                // æ›´æ–°ä¸‹ä¸€å±‚å‚æ•°
                currentY = nextY + 30; // è¿™é‡Œçš„+30æ˜¯ä¸ºäº†è®©å±‚å æ›´æ˜æ˜¾
                currentWidth = currentWidth * 0.7; // å®½åº¦é€’å‡
                lastTopY = nextY;
            }

            // 4. ç»˜åˆ¶é¡¶éƒ¨çš„æ˜Ÿæ˜Ÿ
            drawStar(centerX, lastTopY - 15, 25, 10);
        }

        // --- 4. äº‹ä»¶ç›‘å¬ ---
        window.addEventListener('resize', resizeCanvas);
        
        document.getElementById('generateBtn').addEventListener('click', () => {
             // ç®€å•çš„ç‚¹å‡»åŠ¨ç”»åé¦ˆ
             const btn = document.getElementById('generateBtn');
             generateTree();
        });

        // é¦–æ¬¡è¿è¡Œ
        // ç¨å¾®å»¶æ—¶ç¡®ä¿ Rough.js åŠ è½½å®Œæ¯•ï¼ˆè™½ç„¶CDNåœ¨headé‡Œé€šå¸¸å¾ˆå¿«ï¼‰
        window.onload = resizeCanvas;

    </script>
</body>
</html>